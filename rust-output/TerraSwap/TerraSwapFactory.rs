use cws::runtime::*; // includes CWSContext

fn query_decimals(ctx: CWSContext, msg: QueryDecimals) -> Result<Option<u8>, ContractError> {

  let QueryDecimals { asset_info } = msg;
  
  // TODO: `match` for performance optimization
  if let AssetInfo::Token(x1) = asset_info {
    let token_info = ctx.deps.querier.query_wasm_smart(
      x1.contract_addr,
      TokenInfoQuery {},
    )?;

    return Ok(token_info.decimals);
  }
  
  if let AssetInfo::NativeToken(x1) = asset_info {
    let res = ctx.deps.querier.query_wasm_smart(
      env.contract.address,
      QueryNativeTokenDecimalsRequest {
        denom: asset
      },
    )?;

    return Ok(res.decimals);
  }
}

fn create_pair(ctx: CWSContext, msg: CreatePairMsg) -> Result<Response, ContractErr> {
  let CreatePairMsg { asset_infos } = msg;
  let __response = Response.new();

  if asset_infos[0] == assets_infos[1] {
    return Err(ContractErr::Generic("same asset"));
  }

  let __response = __response
    .add_attributes(vec![
      ("action", "create_pair"),
      ("pair", &format!("{}-{}", asset_infos[0], asset_infos[1])),
    ]);

  let asset_1_decimal = super::fns::query_decimals(ctx.env.contract.address, asset_infos[0]);
  let asset_2_decimal = super::fns::query_decimals(ctx.env.contract.address, asset_infos[1]);
  let asset_decimals = [asset_1_decimal, asset_2_decimal];
  
  let pair_key = String::from(asset_infos[0]) + &String::from(asset_infos[1]);
  let __tmp0: PairInfoRaw = PAIRS.load(deps.storage, &pair_key)?;

  if let Err(_) = __tmp0 {
    return Err(ContractErr::Generic("Pair already exists"));
  }

  TMP_PAIR_INFO.save(
    deps.storage,
    &TmpPairInfo {
      pair_key,
      asset_infos,
      asset_decimals,
    }
  )?;

  let __tmp1 = CONFIG.load(deps.storage)?;

  let __response = __response
    .add_submessage(SubMsg {
      id: 1, // generated by the CWS compiler in consideration of all submessages
      gas_limit: None,
      msg: CosmosMsg::Wasm(WasmMsg::Instantiate {
        code_id: __tmp1.pair_code_id,
        funds: vec![], // default value for omitted funds
        admin: Some(ctx.env.contract.address),
        label: "pair".to_string(),
        // to_binary w/ reference is automatically inserted here
        // only currently possible b/c we know exactly which submessages are available
        msg: to_binary(&PairInstantiateMsg {
          asset_infos,
          token_code_id: __tmp1.token_code_id,
          asset_decimals,
        })?,
      }),
      reply_on: ReplyOn::Success,
    });

  Ok(__response)
}

// TODO: generate reply dispatcher

// explicit struct, cannot be augmented at runtime, but shared with Rust land
PairInfoRaw {
  liquidity_token: pair_info.liquidity_token,
  contract_addr: pair_contract,
  asset_infos: tmp_pair_info.asset_infos,
  asset_decimals: tmp_pair_info.asset_decimals,
}

// generic dict can be augmented at runtime, but not shared with Rust land?
{
  liquidity_token: pair_info.liquidity_token,
  contract_addr: pair_contract,
  asset_infos: tmp_pair_info.asset_infos,
  asset_decimals: tmp_pair_info.asset_decimals
}

// === QUESTIONS ===
// How do we add parameters to submessages?
// Finalize reply syntax?
  
// NullOrErrQExpr
// - result, options - ? / ?? / ! operator
let res = query Wasm::Smart {...}!;

// checks if Some or None
if res? {
  
}

// how to accomplish unwrap_err?
if let Err(ContractErr::Unauthorized(x0, x1)) = res {
  x0
  x1
}

if res is Unauthorized {
  res.0
  res.1
}
